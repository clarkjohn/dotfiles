#!/usr/bin/env bash

# Archive Extraction Function
# Extract archives - use: extract <file>
function a_extract_archive() {
    if [[ -f "$1" ]]; then
        local filename=$(basename "$1")
        local foldername="${filename%%.*}"
        # Using a more robust way to get absolute path without perl dependency
        # Fallback for macOS users with greadlink
        local fullpath=$(readlink -f "$1" || greadlink -f "$1")
        local didfolderexist=false

        if [[ -d "$foldername" ]]; then
            didfolderexist=true
            # -r prevents backslash escapes from being interpreted
            read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1 -r
            echo
            # Check for NOT 'y' or 'Y'
            if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
                # Return 0 for success if user decides not to overwrite
                return 0
            fi
        fi

        # Check if mkdir and cd were successful before proceeding
        if mkdir -p "$foldername" && cd "$foldername"; then
            # Quote $1 for robustness in case statement
            case "$1" in
                *.tar.bz2|*.tb2|*.tbz|*.tbz2) tar xjf "$fullpath" ;;
                *.tar.gz|*.taz|*.tgz) tar xzf "$fullpath" ;;
                *.tar.xz|*.txz) tar Jxvf "$fullpath" ;;
                *.tar|*.tar.Z) tar xf "$fullpath" ;;
                *.zip) unzip "$fullpath" ;;
                *)
                    echo "Error: '$1' cannot be extracted via extract()."
                    # Go back to the original directory
                    cd ..
                    # Only remove if we created it and it still exists
                    if ! "$didfolderexist" && [[ -d "$foldername" ]]; then
                        rm -r "$foldername"
                    fi
                    return 1
                    ;;
            esac
            # Always go back to the original directory after extraction attempt
            cd ..
        else
            echo "Error: Could not create or change into directory '$foldername'."
            return 1
        fi
    else
        echo "Error: '$1' is not a valid file."
        return 1
    fi
}

# Git Workflow Functions

# Temporary save all work in a temp commit
function g_wip() {
    git status -s --long
    git add .
    git commit -a -m "WIP: $*"
    git status -s --long
    return 0
}

# Save current work in a backup branch then do a HARD reset to HEAD
# Based on http://stackoverflow.com/questions/1628088/how-to-reset-my-my-local-repository-to-be-just-like-the-remote-repository-head
function g_reset_to_origin_remove_all_commits() {
    local timestamp
    timestamp=$(date "+%Y-%m-%d-%H_%M_%S")
    local branchname
    branchname=$(git rev-parse --symbolic-full-name --abbrev-ref HEAD)
    local last_non_merge_commit
    last_non_merge_commit=$(git log --no-merges --format=%B -n 1)

    read -p "Backup any changes including untracked files then reset branch $branchname to origin [Y(es backup and reset), N(o just reset)]? " -n 1 -r
    echo

    if [[ "$REPLY" =~ ^[Yy]$ ]]; then
        echo "About to auto-commit any changes, including untracked files:"
        git status -s --long
        git add .
        echo ""
        echo "Autocommit files..."
        git commit -a -m "auto commit was at: $last_non_merge_commit"
        echo "Creating backup auto-save branch: auto-save-$branchname-at-$timestamp"
        git branch "auto-save-$branchname-at-$timestamp"
        echo "Resetting to origin/$branchname..."
        # Always fetch before resetting to ensure origin is up-to-date
        git fetch origin
        git reset --hard "origin/$branchname"
        echo "Removing untracked files..."
        git clean -d -f
    elif [[ "$REPLY" =~ ^[Nn]$ ]]; then
        echo "Resetting to origin/$branchname..."
        # Always fetch before resetting
        git fetch origin
        git reset --hard "origin/$branchname"
        echo "Removing untracked files..."
        git clean -d -f
    else
        echo "Cancelled."
        # Indicate that the operation was cancelled
        return 1
    fi
    # Indicate success
    return 0
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function a_getcertnames() {
    # Use [[ ]] for string tests
    if [[ -z "${1}" ]]; then
        echo "ERROR: No domain specified."
        return 1
    fi

    local domain="${1}"
    echo "Testing ${domain}â€¦"
    echo ""

    local tmp
    # Use printf for better control over output, and pipe to openssl
    tmp=$(printf "GET / HTTP/1.0\\r\\n\\r\\n" | openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1)

    if [[ "${tmp}" == *"-----BEGIN CERTIFICATE-----"* ]]; then
        local certText
        # Ensure proper quoting and continuation for openssl x509 arguments
        certText=$(echo "${tmp}" \
            | openssl x509 -text -certopt "no_header,no_serial,no_version,no_signame,no_validity,no_issuer,no_pubkey,no_sigdump,no_aux")
        echo "Common Name:"
        echo "" # newline
        # More robust CN extraction
        echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//; s/\/.*$//"
        echo "" # newline
        echo "Subject Alternative Name(s):"
        echo "" # newline
        # Use awk for more robust parsing of SANs
        echo "${certText}" | awk '/Subject Alternative Name:/ {getline; gsub(/DNS:|IP Address:| /,""); gsub(/,/,"\n"); print}' | sed '/^$/d'
        return 0
    else
        echo "ERROR: Certificate not found or connection failed."
        return 1
    fi
}

# Show certificates using curl
# https://stackoverflow.com/questions/10079707/https-connection-using-curl-from-command-line
function a_getcertnames_from_endpoint_curl() {
    # Use [[ ]] for string tests
    if [[ -z "${1}" ]]; then
        echo "ERROR: No domain specified."
        return 1
    fi

    # Use -s for silent mode (no progress bar), -S for show errors, -v for verbose output including cert info
    # Use --connect-timeout for better error handling on unreachable hosts
    curl -sS -v --connect-timeout 10 "${1}" 2>&1 | awk 'BEGIN { cert=0 } /^\* Server certificate:/ { cert=1 } /^\*/ { if (cert) print }'
    # This function currently only displays, so always returns success if curl is run
    return 0
}
